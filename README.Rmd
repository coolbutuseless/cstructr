---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)

library(cstructr)
```

# cstructr 

<!-- badges: start -->
![](https://img.shields.io/badge/cool-useless-green.svg)
<!-- badges: end -->

`{cstructr}` is a demonstration package illustrating how a C struct may be
wrapped and manipulated from within R as an external pointer.

This is a "full-service" implementation which makes the internal values
of the struct accessible from R via getters and setters.

For bespoke solutions, a lot of the code could be excised to just keep 
some core functions.


#### Note: The code in this package was auto-generated by parsing the  C struct definition and the C library function declaration.

#### C Struct Definition


```{c eval=FALSE}
typedef struct {
  int N;
  double strength;
} MyCStruct;
```

#### C Library Function Declaration

```{c eval=FALSE}
double multiply(MyCStruct *mycstruct);
```


## Installation

You can install from [GitHub](https://github.com/coolbutuseless/cstructr) with:

``` r
# install.package('remotes')
remotes::install_github('coolbutuseless/cstructr')
```

## Create and Manipulate

```{r example}
library(cstructr)
mycstruct <- MyCStruct(N = 1, strength = 13)
mycstruct

class(mycstruct)
typeof(mycstruct)

mycstruct$N
mycstruct$strength

mycstruct$N <- 3
mycstruct

rm(mycstruct)
gc()
```

Create multiple structs at once

```{r}
lots <- MyCStructs(n = 3)
class(lots)
lots
```



## Call a C library function

1. Write a "bridge function" wrapper (in C) that maps from R objects to C objects
2. Call the C library function from this wrapper
3. Return the result to R in an appropriate container

An example of a C function in a library is as follows.  C libraries know
nothing about R or SEXP objects.

```{c eval=FALSE}
double multiply(MyCStruct *mycstruct) {
  return mycstruct->N * mycstruct->strength;
}
```

The "bridge" function between R and the C library call is written in C as follows.

This function unpacks the externalptr to a real `MyCStruct` pointer, calls the 
C library function, and then returns the results as an R real numeric value.

```{c eval=FALSE}
SEXP multiply_(SEXP mycstruct_ptr_) {
  MyCStruct *mycstruct = external_ptr_to_MyCStruct_ptr(mycstruct_ptr_);
  double res = multiply(mycstruct);
  return ScalarReal(res);
}
```

The call from R is:

```{r eval = FALSE}
multiply <- function(mycstruct) {
  .Call(multiply_, mycstruct)
}
```


All these functions combine such that we can create a pointer to a C struct
in R, and then call the C library function as follows

```{r}
library(cstructr)
mycstruct <- MyCStruct(N=2, strength = 4.5)
multiply(mycstruct)
```


## Auto-generation of bridge function

A lot of the code to wrap a C function and make it callable from R is standard boilerplate.

For simple library functions, you could auto-generate a lot of this R + C code from the 
C function declaration.
